---
title: "典型90問-008"
createdAt: 2026-02-07
contest: "typical90"
problem: "典型90問-008"
difficulty: ""
sourceUrl: "https://atcoder.jp/contests/typical90/tasks/typical90_h"
---

## 問題概要

英小文字からなる長さ `N` の文字列 `S` が与えられます。  
`S` からいくつか（0 個以上）の文字を取り出し、**元の順序を保ったまま**結合してできる文字列が `"atcoder"` になるような取り出し方が何通りあるかを数えます（= `"atcoder"` を部分列として作る方法の数）。答えは大きくなるので `10^9+7` で割った余りを出力します。

問題URL: <https://atcoder.jp/contests/typical90/tasks/typical90_h>

---

## 解法

DPで解く  
0-indexと1-indexを混ぜないように注意

上の方針をもう少しだけ具体化すると、「`S` を左から見ていき、`"atcoder"` の先頭から何文字作れたか」を状態にして数え上げます。  
部分列は「採用する / しない」の選択の積み重ねなので、DP で自然に数えられます。

### DP の定義

`T = "atcoder"`（長さ `J = 7`）として、

- `dp[i][j]` := **`S` の先頭から `i` 文字目まで**（= `S[1..i]`）を見たときに、`T` の先頭 `j` 文字（= `T[1..j]`）を部分列として作る方法の数

とします（ここでは実装に合わせて 1-index で説明します）。

### 遷移

`S` の次の文字 `S[i+1]` を見るとき、選択肢は 2 つです。

1. **採用しない**：`dp[i+1][j] += dp[i][j]`
2. **採用する**：もし `S[i+1] == T[j+1]` なら、`T` を 1 文字進められるので  
   `dp[i+1][j+1] += dp[i][j]`

初期値は「何も見ていない状態で空文字を作る方法は 1 通り」なので `dp[0][0] = 1`。  
最終的に求めたいのは `dp[N][J]`（`T` を全部作れた通り数）です。

※ 取り出し方の数は大きくなるので、各遷移で `MOD = 10^9+7` を取っておくと安全です（Python でも桁が膨らみすぎるのを防げます）。

---

## 実装例

```python
N = int(input())
S = input()
T = "atcoder"
J = len(T)  # 文字数
MOD = 10**9 + 7

# 1-index に寄せて、添字ズレ（0-index と 1-index 混在）を避ける
S = " " + S
T = " " + T

# dp[i][j]: S[1..i] まで見て、T[1..j] を作る方法数
dp = [[0] * (J + 1) for _ in range(N + 1)]

# 0文字目までで0文字の作り方は1通り
# 次の遷移状態にとって都合がいいように考える
dp[0][0] = 1

for i in range(N):  # 次に見るのは S[i+1]
    for j in range(J + 1):
        # S[i+1] を採用しない
        dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD

        # S[i+1] を採用する（T を 1 文字進められるなら）
        if j < J and S[i + 1] == T[j + 1]:
            dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD

print(dp[N][J])
