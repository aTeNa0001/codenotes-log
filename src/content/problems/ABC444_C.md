---
title: "ABC444-C"
createdAt: 2026-02-07
contest: "ABC"
problem: "ABC444-C"
difficulty: ""
sourceUrl: "https://atcoder.jp/contests/abc444/tasks/abc444_c"
---

## 問題概要

長さ `N` の正整数列 `A = (A_1, A_2, ..., A_N)` が与えられる。

ある正整数 `L` について、最初にカップの中に長さ `L` の棒が 1 本以上入っており、シェイク後に各棒は次のいずれかの状態になる。

- 長さ `L` の 1 本の棒としてそのまま残る
- 長さの和が `L` になる 2 本の棒に分かれる（それぞれの長さは正整数）

シェイク後の棒がちょうど `N` 本で、その長さが `A_1, A_2, ..., A_N` であるとき、起こりうる `L` をすべて求める。

少なくとも 1 つは条件を満たす `L` が存在することが保証されている。  
条件を満たす `L` を昇順に空白区切りで 1 行に出力する。

### 制約

- `1 <= N <= 3 * 10^5`
- `1 <= A_i <= 10^9`
- 条件を満たす `L` が少なくとも 1 つ存在する
- 入力はすべて整数

---

## 解法

シェイク後の各棒は、元の長さ `L` の棒が

- そのまま残った（長さ `L` がそのまま 1 本出現）
- 2 本に割れた（2 本の和が `L`）

のどちらかです。したがって、最終的な長さの集合は次のどちらかの形に分類できます。

- **(A) 長さ `L` の棒が 1 本以上含まれる**（＝「そのまま残った」棒がある）
- **(B) 長さ `L` の棒が 1 本も含まれない**（＝すべて割れていて、すべての `A_i` がペアで和 `L` を作る）

この 2 ケースをそれぞれ判定します。配列をソートして両端を突き合わせると、ペアの和が一定かどうかを効率よく確認できます。

### ケース (B): すべて割れている（`L` が出現しない）

すべてが 2 本に割れているなら、最終的な `N` 本はすべてペアになり、`N` は偶数です。  
ソート後の両端を組にして

- `A[0] + A[N-1]`
- `A[1] + A[N-2]`
- ...

がすべて同じ値 `L` になるかを確認します。  
このとき `L` は必ず `A[0] + A[N-1]` になります。

### ケース (A): そのまま残った棒がある（`L` が出現する）

長さ `L` の棒がそのまま残っているなら、割れてできた棒はどれも長さ `L` 未満なので、`L` は配列 `A` の最大値になります。  
よって `L = max(A)` と固定でき、`A` の中の最大値（`L`）の要素は「そのまま残った棒」として扱い、残りの要素がペアで和 `L` を作れるかを確認します。

最大値 `L` の個数を `count_L` とすると、残り `M = N - count_L` 本をペアにする必要があるため `M` は偶数である必要があります。  
ソート済み配列の先頭から `M` 個について両端を組にして、すべての和が `L` になるかをチェックします。

最後に、成立した `L` を重複なく昇順に並べて出力します。

---

## 実装例

```python
N = int(input())
A = list(map(int, input().split()))
A.sort()

answers = set()

# ケース (B): すべて割れている（L が A に出現しない）
if N % 2 == 0:
    cand = A[0] + A[-1]
    ok = True
    for i in range(N // 2):
        if A[i] + A[N - 1 - i] != cand:
            ok = False
            break
    if ok:
        answers.add(cand)

# ケース (A): そのまま残った棒がある（L = max(A)）
L = A[-1]
# 末尾に連続する最大値の個数を数える（A はソート済み）
count_L = 1
i = N - 2
while i >= 0 and A[i] == L:
    count_L += 1
    i -= 1

M = N - count_L  # 最大値以外の本数
if M % 2 == 0:
    ok = True
    for i in range(M // 2):
        if A[i] + A[M - 1 - i] != L:
            ok = False
            break
    if ok:
        answers.add(L)

ans = sorted(answers)
print(*ans)
